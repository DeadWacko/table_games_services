/game1/api/v1/ <-- все энпоинты ниже начинаются с этого
game1 -- имя сервиса (игры), может быть другим, но должно быть частью url; v1 -- версия сервиса (игры).
user_id -- id пользователя в TG.

Эндпоинты для регистрации пользователя и сессии (комнаты):


register/?user=<int:telegram_id>/  <-- запрос пользователя на регистрацию (создание в БД)

find-game/<int:session_id>/?user=<int:user_id>/  <-- поиск активной сессии по коду "комнаты".
сначала пользователь делает запрос. Потом -- бот спрашивает пользователя код комнаты и отправляет на сервис полноценный запрос.
Также надо добавить возможность отправлять пользователям в комнату сообщение о количестве людей в комнате (типа комната ожидания).

start-game/?user=<int:user_id>&places=<int:users_num>/  <-- создание сессии. Бот делает запрос в сервисz и получает код созданной комнаты.

user -- id пользователя в TG, places -- количество пользователей в комнате (задает пользователь. Помним про правила игры).

Эндпоинты для ходов в процессе игры (эндпоинт sessions/<int:session_id>):


Когда все игроки собрались, сервис кроме статуса ответа на запрос на start-game/ присылает еще и данные для старта игры.
Из этого бот выводит порядок хода пользователей, никнейм ведущего на данном ходу, карты (в формате: номер карты и картинка) пользователя.
В конце выводится сообщение из разряда "ожидайте ход ведущего".


<int:move_id>/leading/?message=<str:phrase>&?card=<int:card_id>/ -- ход ведущего: сначала он вводит сообщение и отправляет его боту,
затем -- он выбирает карту и отсылает ее номер также боту. Бот отправляет запрос ведущего сервису
и возвращает пользователю подтверждение или ошибки :)
Если запрос ведущего прошел успешно, то бот также отправляет другим игрокам сообщение ведущего и приглашение к выбору карты.

<int:move_id>/player/?user=<int:user_id>&?card=<int:card_id>/ -- бот получает номер карты и отправляет его в сервис.
Если запрос принят, то бот отписывается в чаты игроков о количестве предложенных игроками карт.


Когда все пользователи отправили ответ:
<int:move_id>/result/ -- бот отправляет get-запрос сервису и получает выбранные пользователями карты (формат: номер карты и картинка).
Бот просит пользователей выбрать картинку и отправить ее номер в чат.

<int:move_id>/result/?user=<int:user_id>&vote=<int:vote_id>/ -- бот отправляет ответ пользователя и получает статус ответа или ошибки.
Когда все пользователи ответили, бот кроме кода статуса ответа на запрос <>/result/<>/ получает еще и результаты раунда.
Бот отправляет результаты (какая карточка ведущего, кто за кого проголосовал и кто сколько получил баллов.
Также промежуточный итог по баллам).

<int:move_id>/next-move/?user=<int:user_id>&?verdict=<int:verdict> -- бот спрашивает пользователя, готов ли тот продолжить игру.
Когда все пользователи готовы, бот получает в ответ данные для следующего хода (см. start-game/).

И так далее... Теперь конец партии: в случае, если карты в руке и колоде закончились, в ответе на конец хода
бот вместе с результатами хода получает и результаты игры!
Соответственно, бот выводит результаты раунда и объявляет об уничтожении сессии (комнаты). Пользователю вновь предлагаются кнопки
перед начало игры.

Эндпоинты для дополнительных действий:


<int:session_id>/endgame/?user=<int:user_id> -- преждевременный выход пользователя из сессии.
После принятия запроса от одного пользователя, сервис автоматически уничтожает сессию, а бот об этом уведомляет.